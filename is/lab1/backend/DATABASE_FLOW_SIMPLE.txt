===================================================================
КАК РАБОТАЕТ БД - КРАТКО
===================================================================

АРХИТЕКТУРА (снизу вверх):
===================================================================

    [PostgreSQL БД]  ← реальные данные в таблицах
           ↕ SQL
    [JDBC Driver]    ← выполняет SQL запросы
           ↕
    [Connection Pool]← 10 соединений готовы к использованию
           ↕
    [Hibernate]      ← конвертирует Java объекты ↔ SQL
           ↕
    [DAO Layer]      ← работает с Session, пишет HQL
           ↕
    [Service Layer]  ← бизнес-логика
           ↕
    [Controller]     ← REST API
           ↕ JSON
    [Клиент браузер]


ПРИМЕР: СОЗДАНИЕ VEHICLE
===================================================================

1. Клиент → POST /api/vehicles + JSON
   ↓

2. Controller получает VehicleCreateDTO
   ↓

3. Service создает объект Vehicle
   Vehicle vehicle = new Vehicle();
   vehicle.setName("Tesla");
   Coordinates coords = new Coordinates(100, 200);
   vehicle.setCoordinates(coords);
   ↓

4. DAO сохраняет через Hibernate
   Session session = sessionFactory.getCurrentSession();
   session.persist(vehicle);
   session.flush();
   ↓

5. Hibernate генерирует SQL
   INSERT INTO coordinates (x, y) VALUES (100, 200);
   INSERT INTO vehicle (name, coordinates_id, ...) 
   VALUES ('Tesla', 1, ...);
   ↓

6. PostgreSQL выполняет и возвращает ID
   coordinates.id = 1
   vehicle.id = 1
   ↓

7. Объект с ID возвращается обратно
   ↓

8. Controller отправляет JSON клиенту
   { "id": 1, "name": "Tesla", ... }


КЛЮЧЕВЫЕ КОМПОНЕНТЫ
===================================================================

HibernateUtil (@Singleton):
├─ Создается при запуске WildFly
├─ Читает Vehicle.hbm.xml и Coordinates.hbm.xml
├─ Создает SessionFactory (один на приложение)
└─ SessionFactory живет всё время работы приложения

SessionFactory:
├─ Тяжелый объект (конфигурация Hibernate)
├─ Thread-safe (можно из разных потоков)
└─ Создает Session для каждой транзакции

Session:
├─ Легкий объект (для одной транзакции)
├─ НЕ thread-safe
├─ getCurrentSession() привязан к JTA транзакции
└─ Автоматически закрывается после транзакции

DataSource (WildFly):
├─ Пул из 10 соединений с PostgreSQL
├─ Соединения переиспользуются
└─ Не создаются заново каждый раз


ТРАНЗАКЦИИ
===================================================================

@Stateless EJB автоматически:

    ┌─────────────────────────────────────┐
    │ EJB Container начинает транзакцию   │
    ├─────────────────────────────────────┤
    │ BEGIN TRANSACTION                   │
    │   ↓                                 │
    │ [ваш код в Service/DAO]             │
    │   ↓                                 │
    │ COMMIT (если OK)                    │
    │ или                                 │
    │ ROLLBACK (если Exception)           │
    └─────────────────────────────────────┘


XML МАППИНГ
===================================================================

Coordinates.hbm.xml:
    Java класс Coordinates  →  Таблица coordinates
    ├─ id (Long)            →  id SERIAL
    ├─ x (double)           →  x DOUBLE PRECISION
    └─ y (long)             →  y BIGINT

Vehicle.hbm.xml:
    Java класс Vehicle      →  Таблица vehicle
    ├─ id (Integer)         →  id SERIAL
    ├─ name (String)        →  name VARCHAR(255)
    ├─ coordinates (объект) →  coordinates_id (FK)
    └─ остальные поля       →  соответствующие колонки


ЧАСТЫЕ ОПЕРАЦИИ
===================================================================

СОЗДАНИЕ (INSERT):
    session.persist(entity);
    session.flush();

ЧТЕНИЕ (SELECT):
    entity = session.get(Vehicle.class, id);
    
    или
    
    Query<Vehicle> query = session.createQuery("FROM Vehicle");
    List<Vehicle> list = query.getResultList();

ОБНОВЛЕНИЕ (UPDATE):
    Vehicle v = session.get(Vehicle.class, 1);
    v.setName("New Name");
    session.flush();  // автоматически обновит БД

УДАЛЕНИЕ (DELETE):
    Vehicle v = session.get(Vehicle.class, 1);
    session.remove(v);
    session.flush();


ВАЖНО ПОНИМАТЬ
===================================================================

✅ Вы работаете с Java объектами
   Vehicle v = new Vehicle();
   v.setName("Tesla");

✅ Hibernate превращает это в SQL автоматически
   INSERT INTO vehicle (name) VALUES ('Tesla');

✅ Транзакции управляются автоматически (@Stateless EJB)

✅ Connection pool переиспользует соединения

✅ XML маппинг связывает классы и таблицы


ЦЕПОЧКА ВЫЗОВОВ (упрощенно)
===================================================================

createVehicle():
    VehicleController.createVehicle()
    → VehicleService.createVehicle()     [BEGIN TX]
      → VehicleDAO.save()
        → Session.persist()
          → Hibernate генерирует SQL
            → JDBC.executeUpdate()
              → PostgreSQL выполняет
              ← возвращает ID
            ← ID записан в объект
          ← объект с ID
        ← сохраненный Vehicle
      ← Vehicle
    ← VehicleDTO                         [COMMIT TX]


ПРОВЕРКА В ЛОГАХ
===================================================================

Когда вы создаете Vehicle, в логах WildFly увидите:

    Hibernate: 
        insert into coordinates (x, y) values (?, ?)
    
    Hibernate: 
        insert into vehicle 
        (name, coordinates_id, creation_date, ...) 
        values (?, ?, ?, ...)

Это означает, что Hibernate работает!


===================================================================





